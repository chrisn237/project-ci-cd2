name: CI/CD Pipeline for Staging and Production

on:
  push:
    branches:
      - main
      - 'feature/*'
  workflow_dispatch:
  release:
    types: [created]

jobs:
  build_test_publish:
    runs-on: ubuntu-latest

    env:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      STAGING_VM_IP: ${{ secrets.STAGING_VM_IP }}
      STAGING_VM_USER: ${{ secrets.STAGING_VM_USER }}
      STAGING_VM_PASSWORD: ${{ secrets.STAGING_VM_PASSWORD }}

    steps:
      # Étape 1 : Checkout du code
      - name: Checkout code
        uses: actions/checkout@v2

      # Étape 2 : Vérifier que VERSION et Changelog.md ont été modifiés (uniquement pour main)
      - name: Check VERSION and Changelog.md
        if: github.ref == 'refs/heads/main'
        run: |
          if ! git diff --exit-code HEAD^ HEAD VERSION Changelog.md; then
            echo "VERSION et Changelog.md ont été modifiés, continue..."
          else
            echo "Erreur : Vous devez modifier VERSION et Changelog.md pour continuer."
            exit 1
          fi

      # Étape 3 : Lire la version depuis le fichier VERSION et définir la variable d'environnement
      - name: Get version from VERSION file
        run: |
          VERSION=$(cat VERSION)
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      # Étape 4 : Déterminer le tag Docker
      - name: Determine Docker tag
        run: |
          if [[ "${GITHUB_REF}" == refs/heads/feature/* ]]; then
            DOCKER_TAG=$(git rev-parse --short HEAD)
          else
            DOCKER_TAG=$VERSION
          fi
          echo "DOCKER_TAG=$DOCKER_TAG" >> $GITHUB_ENV

      # Étape 5 : Configuration de la base de données
      - name: Configure database.ini
        run: |
          sed -i "s/__DB_HOST__/$DB_HOST/g" project/db/resources/database.ini
          sed -i "s/__DB_PORT__/$DB_PORT/g" project/db/resources/database.ini
          sed -i "s/__DB_USER__/$DB_USER/g" project/db/resources/database.ini
          sed -i "s/__DB_PASSWORD__/$DB_PASSWORD/g" project/db/resources/database.ini
          sed -i "s/__DB_NAME__/$DB_NAME/g" project/db/resources/database.ini

      # Étape 6 : Build et Push de l'image Docker
      - name: Build and Push Docker image
        run: |
          docker build -t $DOCKER_USERNAME/apptest1:$DOCKER_TAG .
          echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin
          docker push $DOCKER_USERNAME/apptest1:$DOCKER_TAG

      # Étape 7 : Tests de performance avec K6
      - name: Run Performance Tests with K6
        run: |
          docker run -i grafana/k6 run - < tests/performance.js

      # Étape 8 : Analyse de sécurité avec Trivy
      - name: Run Security Scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: $DOCKER_USERNAME/apptest1:$DOCKER_TAG

      # Étape 9 : Tests fonctionnels
      - name: Run Functional Tests
        run: |
          python -m unittest tests/functional_tests.py

  deploy_staging:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: build_test_publish

    env:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      STAGING_VM_IP: ${{ secrets.STAGING_VM_IP }}
      STAGING_VM_USER: ${{ secrets.STAGING_VM_USER }}
      STAGING_VM_PASSWORD: ${{ secrets.STAGING_VM_PASSWORD }}
      VERSION: $VERSION

    steps:
      - name: Deploy to Staging VM
        run: |
          sshpass -p "$STAGING_VM_PASSWORD" ssh -o StrictHostKeyChecking=no $STAGING_VM_USER@$STAGING_VM_IP << EOF
            docker pull $DOCKER_USERNAME/apptest1:$VERSION
            docker stop staging-container || true
            docker rm staging-container || true
            docker run -d --name staging-container \
              -p 8088:8088 \
              $DOCKER_USERNAME/apptest1:$VERSION
          EOF

  deploy_production:
    if: github.event_name == 'release'
    runs-on: ubuntu-latest
    needs: deploy_staging

    env:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      PROD_VM_IP: ${{ secrets.STAGING_VM_IP }}
      PROD_VM_USER: ${{ secrets.STAGING_VM_USER }}
      PROD_VM_PASSWORD: ${{ secrets.STAGING_VM_PASSWORD }}
      VERSION: $VERSION

    steps:
      - name: Deploy to Production on Staging VM with different port
        run: |
          sshpass -p "$PROD_VM_PASSWORD" ssh -o StrictHostKeyChecking=no $PROD_VM_USER@$PROD_VM_IP << EOF
            docker pull $DOCKER_USERNAME/apptest1:$VERSION
            docker stop production-container || true
            docker rm production-container || true
            docker run -d --name production-container \
              -p 8089:8088 \
              $DOCKER_USERNAME/apptest1:$VERSION
          EOF
