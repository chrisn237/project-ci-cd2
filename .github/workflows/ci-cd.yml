name: CI/CD Pipeline

on:
  push:
    branches:
      - main
      - 'feature/*'
  workflow_dispatch:
  release:
    types: [created]

jobs:
  build_test_publish:
    runs-on: ubuntu-latest

    env:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}

    steps:
      # Étape 1 : Récupération du code source
      - name: Checkout code
        uses: actions/checkout@v2

      # Étape 2 : Vérifier les fichiers dans le workspace
      - name: Debug workspace
        run: |
          echo "Fichiers présents dans le répertoire :"
          ls -l

      # Étape 3 : Lire et valider le fichier VERSION
      - name: Get version from VERSION file
        run: |
          if [ ! -f VERSION ]; then
            echo "Erreur : Le fichier VERSION est introuvable."
            exit 1
          fi
          VERSION=$(cat VERSION | tr -d '\r\n" ')
          if [ -z "$VERSION" ]; then
            echo "Erreur : La variable VERSION est vide après nettoyage."
            exit 1
          fi
          echo "VERSION=$VERSION" >> $GITHUB_ENV

      # Étape 4 : Debug de la variable VERSION
      - name: Debug VERSION
        run: echo VERSION=${{ env.VERSION }}

      # Étape 5 : Validation de la variable VERSION
      - name: Validate VERSION variable
        run: |
          if [ -z "${{ env.VERSION }}" ]; then
            echo "Erreur : La variable VERSION est vide avant utilisation."
            exit 1
          fi

      # Étape 6 : Construire et pousser l'image Docker
      - name: Build and Push Docker image
        run: |
          docker build -t $DOCKER_USERNAME/apptest1:${{ env.VERSION }} .
          echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin
          docker push $DOCKER_USERNAME/apptest1:${{ env.VERSION }}

  deploy_staging:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest
    needs: build_test_publish

    env:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      STAGING_VM_IP: ${{ secrets.STAGING_VM_IP }}
      STAGING_VM_USER: ${{ secrets.STAGING_VM_USER }}
      STAGING_VM_PASSWORD: ${{ secrets.STAGING_VM_PASSWORD }}

    steps:
      - name: Deploy to Staging VM
        run: |
          sshpass -p "$STAGING_VM_PASSWORD" ssh -o StrictHostKeyChecking=no $STAGING_VM_USER@$STAGING_VM_IP << EOF
            echo "Déploiement en cours pour la version ${{ env.VERSION }}..."

            echo "Pulling Docker image..."
            docker pull $DOCKER_USERNAME/apptest1:${{ env.VERSION }}

            echo "Stopping and removing existing container..."
            docker stop staging-container || true
            docker rm staging-container || true

            echo "Running new container..."
            docker run -d --name staging-container \
              -p 8088:8088 \
              $DOCKER_USERNAME/apptest1:${{ env.VERSION }}
          EOF

  deploy_production:
    if: github.event_name == 'release'
    runs-on: ubuntu-latest
    needs: deploy_staging

    env:
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      PROD_VM_IP: ${{ secrets.PROD_VM_IP }}
      PROD_VM_USER: ${{ secrets.PROD_VM_USER }}
      PROD_VM_PASSWORD: ${{ secrets.PROD_VM_PASSWORD }}

    steps:
      - name: Deploy to Production VM
        run: |
          sshpass -p "$PROD_VM_PASSWORD" ssh -o StrictHostKeyChecking=no $PROD_VM_USER@$PROD_VM_IP << EOF
            echo "Déploiement en cours pour la version ${{ env.VERSION }}..."

            echo "Pulling Docker image..."
            docker pull $DOCKER_USERNAME/apptest1:${{ env.VERSION }}

            echo "Stopping and removing existing container..."
            docker stop production-container || true
            docker rm production-container || true

            echo "Running new container..."
            docker run -d --name production-container \
              -p 8089:8088 \
              $DOCKER_USERNAME/apptest1:${{ env.VERSION }}
          EOF
