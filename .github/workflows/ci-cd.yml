name: CI/CD Pipeline 

on:
  push:
    branches:
      - main
  workflow_dispatch:
  release:
    types: [created]

jobs:
  build_test_deploy_staging:
    if: github.ref == 'refs/heads/main'
    runs-on: ubuntu-latest

    env:
      DB_HOST: ${{ secrets.DB_HOST_STAGING }}
      DB_PORT: ${{ secrets.DB_PORT_STAGING }}
      DB_USER: ${{ secrets.DB_USER_STAGING }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD_STAGING }}
      DB_NAME: ${{ secrets.DB_NAME_STAGING }}
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      STAGING_VM_IP: ${{ secrets.STAGING_VM_IP }}
      STAGING_VM_USER: ${{ secrets.STAGING_VM_USER }}
      STAGING_VM_PASSWORD: ${{ secrets.STAGING_VM_PASSWORD }}

    steps:
      # Étape 1 : Checkout du code
      - name: Checkout code
        uses: actions/checkout@v2

      # Étape 2 : Configuration de la base de données
      - name: Configure database.ini
        run: |
          sed -i "s/__DB_HOST__/$DB_HOST/g" project/db/resources/database.ini
          sed -i "s/__DB_PORT__/$DB_PORT/g" project/db/resources/database.ini
          sed -i "s/__DB_USER__/$DB_USER/g" project/db/resources/database.ini
          sed -i "s/__DB_PASSWORD__/$DB_PASSWORD/g" project/db/resources/database.ini
          sed -i "s/__DB_NAME__/$DB_NAME/g" project/db/resources/database.ini

      # Étape 3 : Build et Push de l'image Docker
      - name: Build and Push Docker image
        run: |
          docker build -t $DOCKER_USERNAME/apptest1:latest .
          echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin
          docker push $DOCKER_USERNAME/apptest1:latest

      # Étape 4 : Déploiement en Staging
      - name: Deploy to Staging VM
        env:
          LC_DB_HOST: ${{ env.DB_HOST }}
          LC_DB_PORT: ${{ env.DB_PORT }}
          LC_DB_USER: ${{ env.DB_USER }}
          LC_DB_PASSWORD: ${{ env.DB_PASSWORD }}
          LC_DB_NAME: ${{ env.DB_NAME }}
          LC_DOCKER_USERNAME: ${{ env.DOCKER_USERNAME }}
        run: |
          sshpass -p "$STAGING_VM_PASSWORD" ssh -o StrictHostKeyChecking=no $STAGING_VM_USER@$STAGING_VM_IP << EOF
            docker pull \$LC_DOCKER_USERNAME/apptest1:latest
            docker stop staging-container || true
            docker rm staging-container || true
            docker run -d --name staging-container \
              -e DB_HOST=\$LC_DB_HOST \
              -e DB_PORT=\$LC_DB_PORT \
              -e DB_USER=\$LC_DB_USER \
              -e DB_PASSWORD=\$LC_DB_PASSWORD \
              -e DB_NAME=\$LC_DB_NAME \
              -p 8088:8088 \
              \$LC_DOCKER_USERNAME/apptest1:latest
          EOF

      # Étape 5 : Tests de performance avec K6
      - name: Run Performance Tests with K6
        run: |
          docker run -i grafana/k6 run - < tests/performance.js

      # Étape 6 : Tests de sécurité avec Trivy
      - name: Run Security Scan with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: $DOCKER_USERNAME/apptest1:latest

      # Étape 7 : Tests fonctionnels
      - name: Run Functional Tests
        run: |
          python -m unittest tests/functional_tests.py

  deploy_production:
    if: github.event_name == 'release'
    runs-on: ubuntu-latest
    needs: build_test_deploy_staging

    env:
      DB_HOST: ${{ secrets.DB_HOST_PROD }}
      DB_PORT: ${{ secrets.DB_PORT }}
      DB_USER: ${{ secrets.DB_USER }}
      DB_PASSWORD: ${{ secrets.DB_PASSWORD }}
      DB_NAME: ${{ secrets.DB_NAME }}
      DOCKER_USERNAME: ${{ secrets.DOCKER_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.DOCKER_PASSWORD }}
      PROD_VM_IP: ${{ secrets.STAGING_VM_IP }}
      PROD_VM_USER: ${{ secrets.STAGING_VM_USER }}
      PROD_VM_PASSWORD: ${{ secrets.STAGING_VM_PASSWORD }}

    steps:
      # Étape 1 : Checkout du code
      - name: Checkout code
        uses: actions/checkout@v2

      # Étape 2 : Build et Push de l'image Docker pour Production
      - name: Build and Push Docker image for Production
        run: |
          docker build -t $DOCKER_USERNAME/apptest1:production .
          echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin
          docker push $DOCKER_USERNAME/apptest1:production

      # Étape 3 : Déploiement en Production sur la même VM que Staging
      - name: Deploy to Production on Staging VM with different port
        env:
          LC_DB_HOST: ${{ env.DB_HOST }}
          LC_DB_PORT: ${{ env.DB_PORT }}
          LC_DB_USER: ${{ env.DB_USER }}
          LC_DB_PASSWORD: ${{ env.DB_PASSWORD }}
          LC_DB_NAME: ${{ env.DB_NAME }}
          LC_DOCKER_USERNAME: ${{ env.DOCKER_USERNAME }}
        run: |
          sshpass -p "$PROD_VM_PASSWORD" ssh -o StrictHostKeyChecking=no $PROD_VM_USER@$PROD_VM_IP << EOF
            docker pull \$LC_DOCKER_USERNAME/apptest1:production
            docker stop production-container || true
            docker rm production-container || true
            docker run -d --name production-container \
              -e DB_HOST=\$LC_DB_HOST \
              -e DB_PORT=\$LC_DB_PORT \
              -e DB_USER=\$LC_DB_USER \
              -e DB_PASSWORD=\$LC_DB_PASSWORD \
              -e DB_NAME=\$LC_DB_NAME \
              -p 8089:8088 \
              \$LC_DOCKER_USERNAME/apptest1:production
          EOF
